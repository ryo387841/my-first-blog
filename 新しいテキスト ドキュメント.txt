仮想環境の作成
python -m venv 仮想環境名

仮想環境へ入る
$仮想環境名\Scripts\activate

pipのアップグレード
python -m pip install --upgrade pip

djangoをインストール
pip install django

インストールしたライブラリを記録する
pip freeze > requirements.txt

djangoのプロジェクト作成
django-admin.exe startproject プロジェクト名 .
⇒最後のピリオドは現在のディレクトリにという意味

settings.pyの編集
TIME_ZONE = 'Asia/Tokyo'
LANGUAGE_CODE = 'ja'
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
⇒静的ファイルのパスを追加

DEBUG=TRUEの時は、デプロイするサイトのホスト名を入れる必要がある。
(ワイルドカード(*)も可能だが、ポイズンキャッシュニング対策のため，非推奨）
ALLOWED_HOSTS = ['127.0.0.1', '.pythonanywhere.com']

データベースのセットアップ(デフォルトはsqlite3)
python manage.py migrate

Webサーバーの起動(settings.pyでDEBUG=Falseにすると出来ない）
python manage.py runserver

アプリの作成
python manage.py startapp アプリ名

作成したアプリをdjangoに教える
mysite/settings.pyのINSTALLED_APPSの部分にアプリ名を追

アプリのモデルを作成する(オブジェクトの定義)
アプリ名/models.pyを開き定義。
##########################################################################
from django.utils import timezone


class Post(models.Model):#モデルの定義
#classはオブジェクトであるということ
#Postはモデルの名前←大文字で開始、特殊文字・空白は禁止
#models.ModelはポストがDjango Modelだという意味。Djangoがデータベースで保存すべきものだとわかるように
    author = models.ForeignKey('auth.User', on_delete=models.CASCADE)
    title = models.CharField(max_length=200)
    text = models.TextField()
    created_date = models.DateTimeField(
            default=timezone.now)
    published_date = models.DateTimeField(
            blank=True, null=True)

    def publish(self):#名前に意味はない
        self.published_date = timezone.now()
        self.save()

    def __str__(self):
        return self.title
##########################################################################

models.CharField - 文字数が制限されたテキストを定義するフィールド
models.TextField - これは制限無しの長いテキスト用
models.DateTimeField - 日付と時間のフィールド
models.ForeignKey - 他のモデルへのリンク

その他は下記URLを参照
https://docs.djangoproject.com/ja/2.0/ref/models/fields/#field-types


モデルに変更があったことをDjangoに伝える
python manage.py makemigrations アプリ名

Djangoが用意した移行ファイルをデータベースに追加
python manage.py migrate blog

作成したモデルを追加・編集・削除するためにDjango Adminを使う
アプリ名/admin.pyを編集

from .models import Post#先ほどのclass名
admin.site.register(Post)

python manage.py runserverでサーバーを起動し、http://127.0.0.1:8000/admin/にアクセス

ログインするためにsuperuserを追加
python manage.py createsuperuser

Django Adminについて詳しく知りたい場合
https://docs.djangoproject.com/ja/2.0/ref/contrib/admin/

--デプロイ--
Gitリポジトリを始める
claimyフォルダにいることを確認。

$ git init
$ git config --global user.name "ユーザー名"
$ git config --global user.email you@example.com

Gitに無視してほしいファイルの指定
claimyフォルダ内に.ignoreファイルを作成。
sqlite3を追加しておくことで、テストで作成したデータはローカルのものとなり、
本番環境への影響を無視して作成できる。
##############################
*.pyc
*~
__pycache__
myvenv
db.sqlite3
/static
.DS_Store
##############################

git addを仕様する前や、変更内容を忘れたときは、下記で変更内容を確認
$ git status

変更内容を保存
$ git add --all .
$ git commit -m "My Django Girls app, first commit"

--GitHubにコードをプッシュ--
リポジトリの作成。
"READMEで初期化する"チェックボックスをオフのまま
.gitignoreオプションを空白にして（手動で行っています）
ライセンスをNoneのままにしておく

コンピューター上のリポジトリをGitHub上のリポジトリに結び付ける

$ git remote add origin https://github.com/GitHubのユーザー名/my-first-blog.git
クローンURL：https://github.com/ryo387841/my-first-blog.git
$ git push -u origin master
⇒ユーザー名とパスワードを入力

PythonAnywhereでサイトを設定
Bashを起動（コマンドラインと同じようなもの)


PythonAnywhereにWebアプリケーションをデプロイするには、
コードをGitHubからプルし、PythonAnywhereがそれを認識してWebアプリケーションのサーバを動かし始めるように設定する
手動でもできるが、すべてやってくれるヘルパーツールがある
$ pip3.6 install --user pythonanywhere←Bashで実行

GitHub からアプリを自動的に構成するためのヘルパーを実行
$ pa_autoconfigure_django.py https://github.com/ユーザー名/my-first-blog.git --nuke

--下記を自動で行ってくれている--
最後に--nukeをつけたらエラーを回避できた
・GitHubからコードをダウンロードする
・PythonAnywhere上にvirtualenvを作成する。ちょうどあなたのPC上のように
・一部のデプロイメント設定で設定ファイルを更新する
・manage.py migrateコマンドを使ってPythonAnywhere上のデータベースをセットアップする
・静的ファイルの設定（これについては後で学習します）
APIを通じてPythonAnywhereがあなたのWebアプリケーションを提供するように設定する


データベースは別のため、superuserをもう一度作成する。
 $ python manage.py createsuperuser
基本的にローカルと同じが望ましい

pythonanywhereのWebページからリンクを取得すると自分のサイトが確認できる

実際に運用する際には、下記サイトでセキュリティのチェック
https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/